1. Almost semantically equivalent to C basic disk impl, however we are using safe rust references, but in a trivial way
1.1.5 Thread safe!
1.5 Using egos malloc implementation wrapper around the alloc crate for Rust references.
2. Once we have an interface to C code, subsequent Rust code need only be compatible with other Rust code if built on top, we can write idiomatic Rust (draw diagram thin wrapper in rust for c -> convert to rust, safe, idiomatic with HL abstactions rust -> back to wrapper, then back to c)
3. Start here with SimpleFS traits (interfaces) and impls (methods)

next:
dynamic alloc after making a table of free blocks

1. i talked to yunhao 
it was helpful, another bug popped up though so we're still working on that 
he mentioned that he was surprised you let me use rust because your not the biggest 
fan of it, but he said he doesn't mind the language so i might be able to meet more with him
next week. he said the direction you wanted to take was implementing raid for a 4411 lab 

2. implemnet metadata for the toy filesystem i have now in rust 
3. theres a few blocks in the lowest indices of the disk containing information about 
which blocks in the inodes are not allocated
4. i implemented it with bitflags, i map individual bits to blocks to signal whether they 
have been allocated 
5. theres only one layer of bitflags, so for every block theres 1 bit of overhead
modulo wasted space due to rounding 
6. so every inode has a row in the metadata blocks, the width of the row is 
dynamically computed based on the number of blocks in each inode, i.e. the size
7. code its just arithmetic and bitwise operations

number of blocks 
write offset less than file 
if offset is greater than the 
size 3 block 1 
offset is 3, grow the file to size 4, write the data to block 3
write to offset 8 (error) or grow to size 9 and initialize up to block from 3 up to 8